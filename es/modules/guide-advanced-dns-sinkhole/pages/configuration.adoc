= Configuración
include::{partialsdir}/attributes-es.adoc[]
:guidename: advanced-dns-sinkhole

include::{partialsdir}/download-xlist-database.adoc[leveloffset=1]

== Configuración de xlget

En primer lugar hay que configurar los orígenes de las listas negras definidas, para ello copiaremos de la base de datos xlist los ficheros de definición de `feeds` en `/etc/luids/xlist/sources.d`.

[source,bash]
----
cd /usr/local/share/xlist-database/database
sudo mkdir -p /etc/luids/xlist/sources.d
sudo cp feeds/abuse-ch.json /etc/luids/xlist/sources.d
sudo cp feeds/alienvault-com.json /etc/luids/xlist/sources.d
sudo cp feeds/blocklist-site.json /etc/luids/xlist/sources.d
sudo cp feeds/dshield-org.json /etc/luids/xlist/sources.d
sudo cp feeds/emergingthreats-net.json /etc/luids/xlist/sources.d
sudo cp feeds/interserver-net.json /etc/luids/xlist/sources.d
sudo cp feeds/majestic-com.json /etc/luids/xlist/sources.d
sudo cp feeds/myip-ms.json /etc/luids/xlist/sources.d
sudo cp feeds/phishing-army.json /etc/luids/xlist/sources.d
sudo cp feeds/spamhaus-org.json /etc/luids/xlist/sources.d
sudo cp feeds/zerodot1-coinblockerlists.json /etc/luids/xlist/sources.d
----

Editaremos los ficheros `json` recién copiados y sustituiremos `"disabled": true` por `false` en la definición de las listas enumeradas en el apartado <<design-sources>>.

Editaremos el fichero de configuración de `xlget` para incluir el directorio como fuentes.

.Contenido de `/etc/luids/xlist/xlget.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/xlist/xlget.toml[]
----

Una vez creados dichos ficheros podemos chequear su correcta sintaxis mediante el comando `xlget_check`.
----
# xlget_check
INFO[0000] xlget (version: 341fe0e build: 2020-08-17T07:25:36+0200)
configuration ok
needs update: ....
----

Tras la validación, vamos a realizar la descarga de las listas. Para ello utilizaremos el comando `xlget_update`.
----
# xlget_update
INFO[0000] xlget (version: 341fe0e build: 2020-08-17T07:25:36+0200)
INFO[0000] getting 'blocklist.site-abuse'
INFO[0000] summary 'blocklist.site-abuse': updated=true ip4=0 ip6=0 domain=1220 md5=0 sha1=0 sha256=0
....
INFO[0081] xlget finished
----

En la salida pueden mostrarse algunos _warnings_ (que podremos ignorar si son de formato) y el número de elementos que se han extraído de cada una de las listas. Podemos ver que las listas se han descargado correctamente en el directorio `/var/lib/luids/xlist`.

Para despreocuparnos completamente de la actualización de las listas, inicializaremos el servicio `xlget` para que chequee automáticamente y actualice las listas si es necesario. Además lo habilitaremos para que se inicie con el sistema.

[source,bash]
----
sudo systemctl start luids-xlget
sudo systemctl enable luids-xlget
----

Podremos verificar que se inicia correctamente con el correspondiente `systemctl status luids-xlget`.

== Configuración de xlistd

La configuración de `xlistd` se divide en dos partes:

* Definición del servicio.
* Parámetros de configuración del servidor.

La definición del servicio la realizaremos utilizando múltiples ficheros para que se entienda mejor. Deberemos crear los siguientes ficheros con su correspondiente contenido.

[source,bash]
----
cd /usr/local/share/xlist-database/database
sudo mkdir -p /etc/luids/xlist/services.d
sudo cp file/abuse-ch.json /etc/luids/xlist/services.d
sudo cp file/alienvault-com.json /etc/luids/xlist/services.d
sudo cp file/blocklist-site.json /etc/luids/xlist/services.d
sudo cp file/dshield-org.json /etc/luids/xlist/services.d
sudo cp file/emergingthreats-net.json /etc/luids/xlist/services.d
sudo cp file/interserver-net.json /etc/luids/xlist/services.d
sudo cp file/majestic-com.json /etc/luids/xlist/services.d
sudo cp file/myip-ms.json /etc/luids/xlist/services.d
sudo cp file/phishing-army.json /etc/luids/xlist/services.d
sudo cp file/spamhaus-org.json /etc/luids/xlist/services.d
sudo cp file/zerodot1-coinblockerlists.json /etc/luids/xlist/services.d
----

Editaremos los ficheros `json` recién copiados y sustituiremos `"disabled": true` por `false` en la definición de las listas enumeradas en el apartado <<design-sources>>.

Crearemos un fichero `custom-local.json` que contendrá la definición de nuestra listas negras locales.

.Contenido de `/etc/luids/xlist/services.d/custom-local.json`
[source,json]
----
include::{examplesdir}/etc/luids/xlist/services.d/custom-local.json[]
----

Y crearemos nuestras listas locales.

[source,bash]
----
sudo touch /var/lib/luids/xlist/my-whitelist.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-malware.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-phising.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-reputation.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-ads.xlist
----

Finalmente daremos forma a nuestro servicio de agregación.

.Contenido de `/etc/luids/xlist/service.json`
[source,json]
----
include::{examplesdir}/etc/luids/xlist/service.json[]
----

Editaremos el fichero de configuración del servidor `xlistd` para que utilice nuestra nueva definición de servicio.

.Contenido de `/etc/luids/xlist/xlistd.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/xlist/xlistd.toml[]
----

Comprobaremos que la configuración es correcta, como se muestra a continuación.
----
# xlistd --config /etc/luids/xlist/xlistd.toml --dry-run
INFO[0000] xlistd (version: 341fe0e build: 2020-08-17T07:25:30+0200)
configuration seems ok
----

Inicializaremos y habilitaremos el servicio `xlistd`.

[source,bash]
----
sudo systemctl start luids-xlistd
sudo systemctl enable luids-xlistd
----

Podremos probar el correcto funcionamiento del servidor utilizando el comando `xlistc` para hacerle consultas.
----
$ xlistc
[ip4,domain] (2.666639ms)
$ xlistc www.google.com
domain,www.google.com: false,"",0 (603.587µs)
----

Con el servidor ya configurado, publicaremos el servicio en `apiservices.json` para que el resto de servicios lo puedan utilizar.

.Contenido temporal de `/etc/luids/apiservices.json`
[source,json]
----
[
    {
        "id": "xlist-sinkhole",
        "api": "luids.xlist.v1.Check",
        "endpoint": "tcp://127.0.0.1:5801"
    }
]
----

== Configuración de luarchive

Definiremos los backends de archivado.

.Contenido de `/etc/luids/archive/backends.json`
[source,json]
----
include::{examplesdir}/etc/luids/archive/backends.json[]
----

Definiremos los servicios a publicar por `luarchive`.

.Contenido de `/etc/luids/archive/services.json`
[source,json]
----
include::{examplesdir}/etc/luids/archive/services.json[]
----

Configuraremos los parámetros del servidor.

.Contenido de `/etc/luids/archive/luarchive.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/archive/luarchive.toml[]
----

Probaremos la correcta configuración.
----
# luarchive --config /etc/luids/archive/luarchive.toml --dry-run
INFO[0000] luarchive (version: 874a460 build: 2020-09-03T17:43:38+0200)
configuration seems ok
----

Iniciaremos y habilitaremos el servicio.

[source,bash]
----
sudo systemctl start luids-luarchive
sudo systemctl enable luids-luarchive
----

Con el servidor ya configurado, publicaremos los servicios en `apiservices.json` para que el resto de servicios los puedan utilizar.

.Contenido temporal de `/etc/luids/apiservices.json`
[source,json]
----
[
    {
        "id": "xlist-sinkhole",
        "api": "luids.xlist.v1.Check",
        "endpoint": "tcp://127.0.0.1:5801"
    },
    {
        "id": "dnsutil-archive",
        "api": "luids.dnsutil.v1.Archive",
        "endpoint": "tcp://127.0.0.1:5821"
    },
    {
        "id": "event-archive",
        "api": "luids.event.v1.Archive",
        "endpoint": "tcp://127.0.0.1:5821"
    }
]
----

== Descarga de base de datos de eventos

La manera más sencilla de obtener la base de datos es con un `git clone` o descargando la última release. Podremos dejar la base de datos

[source,bash]
----
git clone https://github.com/luids-io/event-database
sudo mv event-database /usr/local/share
----

== Configuración de eventproc

En primer lugar copiaremos la definición de los tipos de eventos que vamos a procesar.

[source,bash]
----
sudo mkdir -p /etc/luids/event/events.d
cd /usr/local/share/event-database
sudo cp 00-test.json /etc/luids/event/events.d
sudo cp 02-dns.json /etc/luids/event/events.d
----

Definiremos la configuración de las stack de procesado.

.Contenido de `/etc/luids/event/stacks.json`
[source,json]
----
include::{examplesdir}/etc/luids/event/stacks.json[]
----

Configuraremos los parámetros del servidor.

.Contenido de `/etc/luids/event/eventproc.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/event/eventproc.toml[]
----

Probaremos la configuración.
----
# eventproc --config /etc/luids/event/eventproc.toml --dry-run
INFO[0000] eventproc (version: a80418b build: 2020-09-03T17:43:31+0200)
INFO[0000] starting event processor (4 workers)
configuration seems ok
----

Iniciaremos y habilitaremos el servicio.

[source,bash]
----
sudo systemctl start luids-eventproc
sudo systemctl enable luids-eventproc
----

Podemos lanzar un evento de prueba utilizando la utilidad `eventnotify` como muestro a continuación y comprobar que se ha insertado el evento en la base de datos.
----
$ echo '[ { "code": 10000, "data": { "test": "test message" } } ]' | eventnotify --stdin
3361ee82-0cd3-4644-a0c5-c8cff9880dc9
$ mongo
MongoDB shell version v3.6.8
connecting to: mongodb://127.0.0.1:27017
Implicit session: session { "id" : UUID("2445d5f5-d883-4d89-a39a-009e2834b07f") }
MongoDB server version: 3.6.8
> use luidsdb
switched to db luidsdb
> show collections
events
> db.getCollection("events").find()
{ "_id" : "3361ee82-0cd3-4644-a0c5-c8cff9880dc9", "code" : 10000, "level" : 0, "created" : ISODate("2020-09-03T17:26:13.170Z"), "source" : { "hostname" : "luids-router", "program" : "eventnotify", "instance" : "", "pid" : 2949 }, "data" : { "test" : "test message" }, "type" : 1, "codename" : "test.security", "description" : "Test event with data: test message", "processors" : [ { "received" : ISODate("2020-09-03T17:26:13.178Z"), "processor" : { "hostname" : "luids-router", "program" : "eventproc", "instance" : "", "pid" : 2928 } } ], "tags" : [ "test" ] }
> quit()
----

Con el servidor ya configurado y probado, publicaremos el servicio en `apiservices.json` para que el resto de servicios lo puedan utilizar.

.Contenido de `/etc/luids/apiservices.json`
[source,json]
----
include::{examplesdir}/etc/luids/apiservices.json[]
----

== Configuración de ludns

La configuración del servidor DNS la realizaremos en dos fases. En la primera fase lo pondremos a escuchar en el puerto no estándar `1053` para hacer pruebas y comprobar que funciona correctamente. En la segunda fase, que se verá en el apartado siguiente, haremos los pasos necesarios para ponerlo a escuchar en el puerto estándar.

Una vez hecho esto, la configuración del servicio `ludns` es muy sencilla, basta editar el fichero `/etc/luids/dns/Corefile`.

.Contenido temporal `/etc/luids/dns/Corefile`
[source]
----
.:1053 {
  idsapi
  idsevent
  resolvarchive {
     service dnsutil-archive
     server-ip 192.168.1.1
  }
  xlisthole {
     service xlist-sinkhole
     listed-domain merge log=true,dns=nxdomain
     unlisted-domain log=false,dns=checkip
     listed-ip merge log=true,dns=nxdomain,event=info
     #unlisted-ip log=false
     #on-error log=true,dns=return
  }
  forward . 8.8.8.8 8.8.4.4
}
----

Hay que iniciar el servidor.

[source,bash]
----
sudo systemctl start luids-ludns
----

Ahora vamos a llevar a cabo las pruebas del servicio utilizando para ello el comando `dig`.
----
# dig @localhost +short -p 1053 www.google.com //<1>
216.58.211.36
# head -1 /var/lib/luids/xlist/blocklist.site-malware.xlist //<2>
domain,100.1qingdao.com
# dig @8.8.4.4 +short 100.1qingdao.com //<3>
116.255.236.109
# dig @localhost +short -p 1053 100.1qingdao.com //<4>
----
<1> interrogamos al servidor local en puerto `1053` por el dominio
`www.google.com` y obtenemos respuesta.
<2> obtenemos el primer dominio listado en la lista de malware
<3> consultamos a un servidor DNS de google por la existencia del dominio y nos resonde
<4> consultamos a nuestro servidor local por el mismo dominio y no obtenemos
respuesta

Comprobamos en el log del servicio que se ha generado un nuevo evento de chequeo de lista y que lo ha encontrado en una de las listas, como se muestra a continuación.
----
# journalctl -u luids-ludns
...
sep 03 19:39:51 luids-router ludns[3726]: linux/amd64, go1.14.3,
sep 03 19:42:06 luids-router ludns[3726]: [INFO] plugin/xlisthole: [::1]:48554 check '100.1qingdao.com' response: true 'domain-malware'
----

También podemos comprobar la base de datos mongodb en la que veremos que tenemos la resolución realizada y el nuevo evento.
----
$ mongo
> use luidsdb
switched to db luidsdb
> show collections
events
resolvs
> db.getCollection("resolvs").find()
{ "_id" : "ObjectIdHex(\"5f512a7899869d0978394282\")", "timestamp" : ISODate("2020-09-03T17:40:08.238Z"), "duration" : NumberLong(27), "serverip" : "192.168.1.1", "clientip" : "::1", "qid" : 32032, "name" : "www.google.com", "checkingdisabled" : false, "returncode" : 0, "authenticateddata" : false, "resolvedips" : [ "172.217.168.164" ] }
> db.getCollection("events").find()
...
{ "_id" : "22da0489-2e1e-43bf-89f7-750528a36baa", "code" : 10020, "level" : 2, "created" : ISODate("2020-09-03T17:42:06.325Z"), "source" : { "hostname" : "luids-router", "program" : "ludns", "instance" : "", "pid" : 3726 }, "data" : { "listed" : "100.1qingdao.com", "query" : "100.1qingdao.com", "reason" : "domain-malware: found in 'blocklist.site-malware'", "remote" : "::1" }, "type" : 1, "codename" : "dns.listed_domain", "description" : "Domain '100.1qingdao.com' listed has been resolved by ::1", "processors" : [ { "received" : ISODate("2020-09-03T17:42:06.327Z"), "processor" : { "hostname" : "luids-router", "program" : "eventproc", "instance" : "", "pid" : 2928 } } ], "tags" : [ "blacklist", "dns" ] }
> quit()
----

== Consolidación servicio DNS

Ya tenemos un servidor DNS funcionando pero en un puerto no estándar, así que debemos cambiarlo al puerto que le corresponde. Sin embargo, aquí puede surgir un pequeño problema: puede existir un servidor DNS ya corriendo en dicho puerto.

Esto se debe a que muchas distribuciones optan por poner un pequeño servidor DNS funcionando por defecto para resolver las peticiones locales. Los más habituales son `systemd-resolved` y `dnsmasqd`.

Esta guía está realizada sobre un _Ubuntu 20.04_, por lo que desactivaremos `systemd-resolved` con los siguientes comandos.

[source,bash]
----
sudo -s
## deshabilito systemd-resolved
systemctl disable systemd-resolved.service
systemctl stop systemd-resolved.service

## borro symlink
rm -f /etc/resolv.conf

## creo nuevo resolv.conf que use el servidor dns local
cat >/etc/resolv.conf <<EOF
nameserver 127.0.0.1
options edns0
EOF
----

Ahora modificaremos la configuración de nuestro servidor DNS con la configuración definitiva.

.Contenido definitivo de `/etc/luids/dns/Corefile`
[source]
----
. {
   idsapi
   idsevent
   resolvarchive {
      service dnsutil-archive
      server-ip 192.168.1.1
   }
   xlisthole {
      service xlist-sinkhole
      listed-domain merge log=true,dns=nxdomain
      unlisted-domain log=false,dns=checkip
      listed-ip merge log=true,dns=nxdomain,event=info
      #unlisted-ip log=false
      #on-error log=true,dns=return
   }
   forward . 8.8.8.8 8.8.4.4
}
----

Reiniciaremos y habilitaremos el servicio al inicio.

[source,bash]
----
sudo systemctl restart luids-ludns
sudo systemctl enable luids-ludns
----

¡Ya tenemos configurado nuestro sumidero DNS!.

== Configuración de los clientes

IMPORTANT: Los clientes se deberán configurar para que usen la _IP_ de nuestro
sumidero como *único servidor DNS*. De lo contrario algunas preguntas podrán
ser contestadas por otro servidor DNS que no haga el filtrado.

Una configuración adicional recomendada es permitir únicamente la salida de
tráfico DNS de nuestra red a nuestro servidor DNS. Esto no sólo evitará que
algunos usuarios puedan cambiarse la dirección del servidor DNS de forma manual
para evadir a nuestro sumidero, sino que también hará que posible malware use
servicios DNS públicos para evitar ser detectados.

ifdef::env-site,env-github[]
A continuación: xref:next-steps.adoc[Siguientes pasos]
endif::env-site,env-github[]
