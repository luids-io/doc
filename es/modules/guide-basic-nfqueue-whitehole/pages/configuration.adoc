= Configuración
include::{partialsdir}/attributes-es.adoc[]
:guidename: basic-nfqueue-whitehole

== Configuración de resolvcache

Para este servicio no hay que hacer ninguna configuración, ya que la configuración por defecto es suficiente.

Iniciaremos y habilitaremos el servicio.

[source,bash]
----
sudo systemctl start luids-resolvcache
sudo systemctl enable luids-resolvcache
----

Con el servidor ya configurado, publicaremos los servicios en `apiservices.json` para que el resto de servicios los puedan utilizar.

.Contenido temporal de `/etc/luids/apiservices.json`
[source,json]
----
[
    {
        "id": "resolvcache",
        "api": "luids.dnsutil.v1.ResolvCollect",
        "endpoint": "tcp://127.0.0.1:5891"
    },
    {
        "id": "resolvcheck",
        "api": "luids.dnsutil.v1.ResolvCheck",
        "endpoint": "tcp://127.0.0.1:5891"
    }
]
----


== Configuración de xlistd

La configuración de `xlistd` se divide en dos partes:

* Definición del servicio.
* Parámetros de configuración del servidor.

Definiremos el servicio y crearemos el fichero que almacenará nuestra lista blanca.

.Contenido de `/etc/luids/xlist/service.json`
[source,json]
----
include::{examplesdir}/etc/luids/xlist/service.json[]
----

.Contenido de `/var/lib/luids/xlist/my-whitelist.xlist`
[source]
----
domain,sub,ubuntu.com
domain,sub,luids.io
domain,plain,www.luisguillen.com
----

Editaremos el fichero de configuración del servidor `xlistd` para que utilice nuestra nueva definición de servicio.

.Contenido de `/etc/luids/xlist/xlistd.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/xlist/xlistd.toml[]
----

Comprobaremos que la configuración es correcta, como se muestra a continuación.
----
# xlistd --config /etc/luids/xlist/xlistd.toml --dry-run
INFO[0000] xlistd (version: adf9e50 build: 2020-09-10T06:39:54+0200)
configuration seems ok
----

Inicializaremos y habilitaremos el servicio `xlistd`.

.Inicializa servicio `xlistd` y habilita al inicio
[source,bash]
----
sudo systemctl start luids-xlistd
sudo systemctl enable luids-xlistd
----

Podremos probar el correcto funcionamiento del servidor utilizando el comando `xlistc` para hacerle consultas.
----
$ xlistc
[domain] (1.415126ms)
$ xlistc www.google.com
domain,www.google.com: true,"not whitelisted",5 (341.088µs)
$ xlistc www.ubuntu.com
domain,www.ubuntu.com: false,"",5 (964.664µs)
----

Con el servidor ya configurado, publicaremos el servicio en `apiservices.json` para que el resto de servicios los puedan utilizar.

.Contenido definitivo de `/etc/luids/apiservices.json`
[source,json]
----
include::{examplesdir}/etc/luids/apiservices.json[]
----

== Configuración de ludns

Configuraremos inicialmente el servidor DNS en el puerto de `1053` para que utilice la API y los plugins `xlisthole` y `resolvcache`.

.Contenido temporal de `/etc/luids/dns/Corefile`
[source]
----
.:1053 {
    idsapi
    xlisthole
    resolvcache
    forward . 8.8.8.8 8.8.4.4
}
----

Iniciaremos y probaremos que el servicio de resolución está almacenando las peticiones.

[source,bash]
----
sudo systemctl start luids-ludns
----

Comprobaremos que todo funciona correctamente
----
$ dig +short @localhost -p 1053 www.google.com //<1>
$ sudo tail /var/log/syslog //<2>
...
Oct  8 08:12:47 luids-router systemd[1]: Started ludns luIDS service.
Oct  8 08:12:48 luids-router ludns[1516]: .:1053
Oct  8 08:12:48 luids-router ludns[1516]: CoreDNS-1.7.0
Oct  8 08:12:48 luids-router ludns[1516]: linux/amd64, go1.14.3,
Oct  8 08:13:11 luids-router ludns[1516]: [INFO] plugin/xlisthole: [::1]:50918 check 'www.google.com' response: true 'not whitelisted'
...
$ dig +short @localhost -p 1053 ntp.ubuntu.com //<3>
91.189.89.199
91.189.94.4
91.189.89.198
91.189.91.157
$ sudo cat /var/lib/luids/dns/cache-trace.log //<4>
20201008081330,collect,127.0.0.1:60880,::1,ntp.ubuntu.com,91.189.89.199,91.189.94.4,91.189.89.198,91.189.91.157
----
<1> interrogamos al servidor local en puerto `1053` por el dominio `www.google.com` y NO obtenemos respuesta porque no está en la lista blanca.
<2> comprobamos en el log que el servidor dns está adviritendo de un intento frustrado de resolución.
<3> interrogamos a nuestro servidor dns por un elemento que sí está en la lista y devuelve las ips correspondientes.
<4> comprobamos en el log de traza de la caché que se almacenan correctamente las resoluciones.

== Consolidación servicio DNS

Ya tenemos un servidor DNS funcionando pero en un puerto no estándar, así que debemos cambiarlo al puerto que le corresponde. Sin embargo, aquí puede surgir un pequeño problema: puede existir un servidor DNS ya corriendo en dicho puerto.

Esto se debe a que muchas distribuciones optan por poner un pequeño servidor DNS funcionando por defecto para resolver las peticiones locales. Los más habituales son `systemd-resolved` y `dnsmasqd`.

Esta guía está realizada sobre un _Ubuntu 20.04_, por lo que desactivaremos `systemd-resolved` con los siguientes comandos.

[source,bash]
----
sudo -s
## deshabilito systemd-resolved
systemctl disable systemd-resolved.service
systemctl stop systemd-resolved.service

## borro symlink
rm -f /etc/resolv.conf

## creo nuevo resolv.conf que use resolvedores remotos
cat >/etc/resolv.conf <<EOF
nameserver 8.8.8.8
nameserver 8.8.4.4
options edns0
EOF
----

NOTE: Es posible crear varias configuraciones para tener un servidor dns que atienda las peticiones locales y otro que atienda las de la red. Por simplicidad hemos optado por la configuración que aquí se muestra.

Ahora modificaremos la configuración de nuestro servidor DNS con la configuración definitiva.

.Contenido definitivo de `/etc/luids/dns/Corefile`
[source]
----
. {
    idsapi
    xlisthole
    resolvcache
    cache
    forward . 8.8.8.8 8.8.4.4
}
----

Reiniciaremos y habilitaremos el servicio.

[source,bash]
----
sudo systemctl restart luids-ludns
sudo systemctl enable luids-ludns
----

== Configuración de lunfqueue

La configuración nuevamente se divide en configuración del servidor y definición del servicio.

.Contenido de `/etc/luids/netfilter/lunfqueue.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/netfilter/lunfqueue.toml[]
----

IMPORTANT: Deberás reemplazar la dirección de red `192.168.250.0/24` por la de tu red local.

El servicio se configurará mediante la definición de los plugins y acciones que se van a aplicar. Esto se realizará mediante el siguiente fichero de configuración.

.Contenido de `/etc/luids/netfilter/plugins-nfqueue.json`
[source,json]
----
include::{examplesdir}/etc/luids/netfilter/plugins-nfqueue.json[]
----

Testearemos que la configuración es correcta.
----
# lunfqueue --config /etc/luids/netfilter/lunfqueue.toml --dry-run
INFO[0000] lunfqueue (version: f096c19 build: 2020-09-10T06:45:40+0200)
configuration seems ok
----

Una vez probado, inicializaremos y habilitaremos el servicio

[source,bash]
----
sudo systemctl start luids-lunfqueue
sudo systemctl enable luids-lunfqueue
----

Ya tenemos configurado un servicio que escucha la entrada de paquetes en la cola netfilter `100`. Ahora deberemos dirigir los paquetes que deseemos filtrar a dicha cola.

== Configuración de netfilter mediante iptables

Vamos a configurar el sencillo firewall mediante el siguiente script. Nótese que únicamente dejaremos pasar el tráfico `icmp` para pruebas de conexión y el tráfico por los puertos `80` y `443` para navegación.

.Contenido de `init-firewall.sh`
[source,bash]
----
include::{examplesdir}/init-firewall.sh[]
----

Lo ejecutaremos.

[source,bash]
----
chmod 755 init-firewall.sh
sudo ./init-firewall.sh
----

Ya tendremos nuestro cortafuegos configurado, ahora *desde una máquina dentro de la red interna* testearemos.
----
(RED-INTERNA)$ ping -c 3 www.ubuntu.com //<1>
PING www.ubuntu.com (91.189.88.181) 56(84) bytes of data.
64 bytes from davybones.canonical.com (91.189.88.181): icmp_seq=1 ttl=61 time=47.2 ms
64 bytes from davybones.canonical.com (91.189.88.181): icmp_seq=2 ttl=61 time=45.9 ms
64 bytes from davybones.canonical.com (91.189.88.181): icmp_seq=3 ttl=61 time=45.5 ms

--- www.ubuntu.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2003ms
rtt min/avg/max/mdev = 45.454/46.183/47.190/0.735 ms

(RED-INTERNA)$ ping -c 3 www.google.com //<2>
ping: www.google.com: Nombre o servicio desconocido

(RED-INTERNA)$ ping -c 3 8.8.8.8 //<3>
PING www.google.com (8.8.8.8) 56(84) bytes of data.

--- 8.8.8.8 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 2023ms
----
<1> La conexión con una máquina de la lista blanca funciona correctamente.
<2> La resolución de dominios que no estén en la lista blanca son contestadas con un "no existe el dominio".
<3> Si tratamos de conectar directamente por ip no funciona ya que la dirección no se ha resuelto previamente por la máquina que hace el ping.

En el log de nuestro firewall tendremos algo parecido a lo siguiente.
----
# tail -f /var/log/syslog | grep -i lunfqueue
Oct  8 08:40:52 luids-router lunfqueue[1880]: time="2020-10-08T08:40:52+02:00" level=info msg="ip-processor.checkresolv: 192.168.250.100->8.8.8.8 8.8.8.8 {Result:false Last:0001-01-01 00:00:00 +0000 UTC Store:2020-10-08 06:10:35.450032698 +0000 UTC}"
Oct  8 08:40:53 luids-router lunfqueue[1880]: time="2020-10-08T08:40:53+02:00" level=info msg="ip-processor.checkresolv: 192.168.250.100->8.8.8.8 8.8.8.8 {Result:false Last:0001-01-01 00:00:00 +0000 UTC Store:2020-10-08 06:10:35.450032698 +0000 UTC}"
Oct  8 08:40:54 luids-router lunfqueue[1880]: time="2020-10-08T08:40:54+02:00" level=info msg="ip-processor.checkresolv: 192.168.250.100->8.8.8.8 8.8.8.8 {Result:false Last:0001-01-01 00:00:00 +0000 UTC Store:2020-10-08 06:10:35.450032698 +0000 UTC}"
----

En la traza de la caché tendremos algo parecido a lo siguiente.

[source,console]
----
# cat /var/lib/luids/dns/cache-trace.log
...
20201008084053,check,127.0.0.1:60894,192.168.250.100,,8.8.8.8,false
20201008084054,check,127.0.0.1:60894,192.168.250.100,,8.8.8.8,false
20201008084054,check,127.0.0.1:60894,192.168.250.100,,8.8.8.8,false
20201008084117,collect,127.0.0.1:60892,192.168.250.100,www.ubuntu.com,91.189.88.181,91.189.88.180,91.189.91.44,91.189.91.45
20201008084117,collect,127.0.0.1:60892,192.168.250.100,www.ubuntu.com,2001:67c:1360:8001::2c,2001:67c:1562::1f,2001:67c:1562::20,2001:67c:1360:8001::2b
20201008084117,check,127.0.0.1:60894,192.168.250.100,,91.189.88.181,true
20201008084117,check,127.0.0.1:60894,192.168.250.100,,91.189.88.181,true
...
----

== Consolidación del firewall

Ahora que hemos comprobado que el sistema funciona correctamente sólo falta hacer las reglas que hemos definido persistentes para ello simplemente introduciremos.

[source,bash]
----
sudo -s
sed -i 's/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/' /etc/sysctl.conf
iptables-save > /etc/iptables/rules.v4
ip6tables-save > /etc/iptables/rules.v6
----

ifdef::env-site,env-github[]
A continuación: xref:next-steps.adoc[Siguientes pasos]
endif::env-site,env-github[]
