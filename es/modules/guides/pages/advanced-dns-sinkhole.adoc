ifdef::env-site,env-github[= Guía: Sumidero DNS avanzado para bloquear publicidad y malware]
include::{partialsdir}/attributes-es.adoc[]
ifdef::env-site,env-github[:toc:]

En la siguiente guía vamos a ver cómo configurar un *sumidero DNS*, también conocido como _DNS Sinkhole_ o _DNS Blackhole_, en nuestra red para bloquear _banners_, intentos de _phising_ y conexiones a sitios relacionados con _malware_. Como no es lo mismo un sitio de publicidad que uno de _phising_, el sistema los tratará de forma diferente y generará (o no) eventos de diferente nivel para cada caso.

Las funcionalidades de nuestro sumidero serán:

* chequeará los nombres de dominio a resolver en diferentes listas negras y, dependiendo del caso, chequeará además las IP devueltas.
* responderá en función de las políticas aplicadas a cada tipo de lista negra, pudiendo devolver desde un "dominio no existente" a una determinada IP,
* dichas políticas determinarán también el nivel de evento que se generará,
* archivaremos las resoluciones DNS en una base de datos MongoDB,
* archivaremos los eventos que se generen en una base de datos MongoDB

NOTE: Puedes realizar la configuración de esta guía *en menos de 5 minutos* únicamente con la información de los apartados de <<installation>> y <<configuration>>. Además tienes a tu disposición todos los ficheros de configuración de esta guía https://github.com/luids-io/docs/blob/master/es/modules/guides/examples/advanced-dns-sinkhole[aquí].

IMPORTANT: La configuración de esta guía también está disponible en *docker*. Puedes acceder a ella en nuestro https://github.com/luids-io/deploy[repositorio de despliegues de luIDS]. Concretamente en https://github.com/luids-io/deploy/docker/advanced-dns-sinkhole. Existe además una versión con instrumentación de esta configuración en https://github.com/luids-io/deploy/docker/advanced-dns-sinkhole-metrics.


[[introduction]]
== Introducción

=== Qué es un sumidero DNS o DNS Sinkhole

Un sumidero DNS es un servidor DNS que cumple el rol de _resolvedor_ en una red pero que, en lugar de devolver directamente a los clientes el resultado de una consulta DNS, comprobará si el nombre consultado se encuentra en una lista negra. Si se encontrase en la lista, entonces el sumidero no realizará la resolución y devolverá al cliente que el dominio no existe. Si el dominio no estuviese en la lista, el sumidero chequeará también las direcciones IP devueltas por el DNS y devolverá el resultado de la consulta al cliente si no estuviese en ninguna lista.

Para entender mejor el funcionamiento, puede verse el siguiente diagrama de secuencia.

[[diagram-sinkhole-sequence]]
.Secuencia de un sumidero DNS con xlist
[plantuml, diagram-advanced-sinkhole-sequence, png, pdfwidth=70%]
----
actor dnsclient
participant "DNS Server\n(ludns)" as dnsserver
participant "XList Server\n(xlistd)" as xlist
participant "External\nDNS Server" as dnsext #99FF99

dnsclient -> dnsserver: query www.google.com
dnsserver -> xlist: Check(wwww.google.com)
xlist --> dnsserver: {result: false}
dnsserver -> dnsext: query www.google.com
dnsext --> dnsserver: 1.2.3.4, 9.8.7.6
dnsserver -> xlist: Check(1.2.3.4)
dnsserver -> xlist: Check(9.8.7.6)
xlist --> dnsserver: {result: false}
xlist --> dnsserver: {result: false}
dnsserver --> dnsclient: 1.2.3.4, 9.8.7.6

dnsclient -> dnsserver: query www.infected.com
dnsserver -> xlist: Check(wwww.infected.com)
xlist --> dnsserver:  {result: true, reason: "is malware"}
dnsserver --> dnsclient: nxdomain
----

=== ¿Qué tiene de especial nuestro sumidero?

Como probablemente conozca el lector, ya existe diverso software capaz de realizar esta labor, sin embargo la mayoría no es libre y el que es libre (como el popular BIND), usa un planteamiento distinto y, a nuestro juicio, menos versátil.

La particularidad de nuestro sumidero es que, como se vio en la figura <<diagram-sinkhole-sequence>>, involucra diferentes componentes: por un lado tenemos un servidor _DNS_ (basado en el popular _CoreDNS_) que realiza las tareas típicas de resolución y, por otro lado, tenemos un servidor _XList_ que se encarga de la tarea de comprobar la existencia en las listas. Esta separación de responsabilidades nos permitirá, además de una alta especialización de cada software en su correspondiente rol, implementar sistemas más robustos y escalables.

Esta guía se trata de una configuración básica así que no se verán todas las funcionalidades que ofrece nuestro sumidero. Sin embargo, conviene que el usuario las conozca por si se anima a continuar explorando más allá de esta guía. Algunas de las funcionalidades adicionales son:

* es posible definir puntuaciones y umbrales de respuesta,
* es posible hacer uso de otros elementos además de las listas, como la geolocalización,
* permite la integración con cortafuegos _netfilter_ de forma que el cortafuegos no permita la comunicación con una dirección IP si dicha dirección no ha sido previamente resuelta,
* provee de instrumentación para su integración en un sistema de monitorización _Prometheus_ y así tener información en "tiempo real",
* disponible en _Docker_ y con algunas características que lo hace ideal para su despliegue en entornos Cloud con herramientas como _Kubernetes_.

Así que una vez visto qué es un sumidero y qué ventajas aporta nuestro software sobre otros, pongámonos manos a la obra.


[[design]]
== Diseño del sistema

[[design-sources]]
=== Selección de los orígenes

En primer lugar vamos a seleccionar los orígenes que vamos a utilizar. Un buen sitio por donde empezar es https://github.com/luids-io/xlist-database[la base de datos XList].

Al tratarse de un sumidero DNS, vamos a querer una baja latencia en las consultas a las listas. Aquí tenemos dos opciones:

. Utilizar fuentes online de pago que nos garanticen calidad de servicio.
. Utilizar fuentes que puedan descargarse para su uso "offline".

Dado que el objetivo de esta guía es obtener un sumidero DNS de forma gratuita, optaremos por la segunda opción. Además, debido a que queremos un sumidero que chequee las IPs retornadas, utilizaremos listas para los recursos `domain` e `ip4`.

Haremos la siguiente categorización de listas en función del tipo de información que almacenan.

.Tabla con listas incluídas
[cols="1,3"]
|===
| Tipo | Listas

| Dominios malware
| `blocklist.site-malware` `blocklist.site-ransomware` `abuse.ch-urlhaus`

| Dominios phising
| `blocklist.site-phishing` `phising.army`

| Dominios crypto
| `blocklist.site-crypto` `zerodot1-coinblockerlists`

| Dominios baja reputación
| `blocklist.site-fraud` `blocklist.site-scam` `blocklist.site-abuse`

| Dominios tracking
| `blocklist.site-tracking`

| Dominios ads
| `blocklist.site-ads`

| Dominios redirección
| `blocklist.site-redirect`

| IP malware
| `blocklist.site-malware` `abuse.ch-ssl` `dshield.org` `emergingthreats.net` `interserver.net`

| IP baja reputación
| `alienvault.com` `myip.ms-full` `spamhaus.org-drop`

|===

Para eliminar el número de falsos positivos con los dominios, incluiremos una lista blanca con los primeros 1000 dominios de la base de datos _Majestic_ que viene identificada por `majestic-1000` y una lista blanca que rellenaremos manual mente para dominios y direcciones ip a la que llamaremos `my-whitelist`.

Además incluiremos las siguientes listas negras propias a las que podremos agregar elementos (tanto dominios como ips): `my-blacklist-malware`, `my-blacklist-phising`, `my-blacklist-reputation` y `my-blacklist-ads`.

[[design-service]]
=== Diseño del servicio de listas

Nuestro servicio de listas, comprobará en primer lugar en las listas blancas que hemos definido y después en listas negras. Posteriormente, las políticas que se aplicarán para cada tipo de lista serán las siguientes.

.Tabla con listas incluidas por categoría y política utilizada
[cols="1,3"]
|===
| Tipo | Política

| Dominios malware
| `dns=nxdomain,event=medium`

| Dominios phising
| `dns=nxdomain,event=low`

| Dominios crypto
| `dns=nxdomain,event=info`

| Dominios baja reputación
| `dns=nxdomain,event=info`

| Dominios tracking
| `dns=nxdomain,event=none`

| Dominios ads
| `dns=nxdomain,event=none`

| Dominios redirección
| `dns=checkip,event=info`

| IP malware
| `dns=nxdomain,event=medium`

| IP phising
| `dns=nxdomain,event=low`

| IP baja reputación
| `dns=nxdomain,event=low`

| IP ads
| `dns=nxdomain,event=none`

|===

[[design-components]]
=== Despliegue de los componentes

Como vamos a desplegar el software sobre un único sistema, el diagrama de despliegue quedará de la siguiente forma:

.*Diagrama de despliegue*
[plantuml, deployment-advanced-sinkhole, png,pdfwidth=70%]
----
cloud "External Resolver" {
 [DNS Server] -right- ExtDNS
}

cloud "Blacklists" {
 [Web server] -down- HTTP
}

node "XList server" {
  database "xlistdb"
  [xlget] --> xlistdb
  [xlget] --> HTTP
  [xlistd] --> xlistdb
  [xlistd] - GRPC_X
}

node "DNS server" {
  [ludns] --> GRPC_X
  [ludns] --> ExtDNS
  [ludns] -up- DNS
}

node "Event server" {
  [eventproc] -up- GRPC_E
}

[ludns] --> GRPC_E

node "Archiver" {
  database "MongoDB"
  [luarchive] --> MongoDB
  [luarchive] - GRPC_A
}

[ludns] --> GRPC_A
[eventproc] --> GRPC_A

node "Client" {
  [DNS Resolver] --> DNS
}
----

NOTE: En esta guía desplegaremos los componentes `xlistd`, `xlget`, `ludns`, `luarchive`, `eventproc` vistos en el diagrama.

[[installation]]
== Instalación

WARNING: Este proceso está probado únicamente en un sistema _Ubuntu 20.04LTS_
server. Los binarios están compilados estáticamente y las rutas empleadas son
las de una distribución estándar, por lo que el instalador debería funcionar en
cualquier distribución. Si necesita más información o quiere instalarlo sobre
otras plataformas puede consultar los xref:manuals:index.adoc[manuales de las
herramientas].

IMPORTANT: Recuerde que si prefiere usar `docker` también puede desplegar el escenario de esta guía https://github.com/luids-io/deploy/docker/advanced-dns-sinkhole[usando docker compose].

include::{partialsdir}/install-xlist.adoc[leveloffset=2]

include::{partialsdir}/install-dns.adoc[leveloffset=2]

include::{partialsdir}/install-event.adoc[leveloffset=2]

include::{partialsdir}/install-archive.adoc[leveloffset=2]

=== Instalación de mongodb

[source,bash]
----
sudo apt install mongodb-server
----

[[configuration]]
== Configuración

IMPORTANT: Puede descargar los ficheros de configuración de esta guía
https://github.com/luids-io/docs/blob/master/es/modules/guides/examples/advanced-dns-sinkhole[aquí].


=== Descarga de base de datos xlist

La manera más sencilla de obtener la base de datos es con un `git clone` o descargando la última release. Podremos dejar la base de datos

[source,bash]
----
git clone https://github.com/luids-io/xlist-database
sudo mv xlist-database /usr/local/share
----

=== Configuración de xlget

En primer lugar hay que configurar los orígenes de las listas negras definidas, para ello copiaremos de la base de datos xlist los ficheros de definición de `feeds` en `/etc/luids/xlist/sources.d`.

[source,bash]
----
cd /usr/local/share/xlist-database/database
sudo mkdir -p /etc/luids/xlist/sources.d
sudo cp feeds/abuse-ch.json /etc/luids/xlist/sources.d
sudo cp feeds/alienvault-com.json /etc/luids/xlist/sources.d
sudo cp feeds/blocklist-site.json /etc/luids/xlist/sources.d
sudo cp feeds/dshield-org.json /etc/luids/xlist/sources.d
sudo cp feeds/emergingthreats-net.json /etc/luids/xlist/sources.d
sudo cp feeds/interserver-net.json /etc/luids/xlist/sources.d
sudo cp feeds/majestic-com.json /etc/luids/xlist/sources.d
sudo cp feeds/myip-ms.json /etc/luids/xlist/sources.d
sudo cp feeds/phishing-army.json /etc/luids/xlist/sources.d
sudo cp feeds/spamhaus-org.json /etc/luids/xlist/sources.d
sudo cp feeds/zerodot1-coinblockerlists.json /etc/luids/xlist/sources.d
----

Editaremos los ficheros `json` recién copiados y sustituiremos `"disabled": true` por `false` en la definición de las listas enumeradas en el apartado <<design-sources>>.

Editaremos el fichero de configuración de `xlget` para incluir el directorio como fuentes.

.Contenido de `/etc/luids/xlist/xlget.toml`
[source,toml]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/xlist/xlget.toml[]
----

Una vez creados dichos ficheros podemos chequear su correcta sintaxis mediante el comando `xlget_check`.

[source,console]
----
# xlget_check
INFO[0000] xlget (version: 341fe0e build: 2020-08-17T07:25:36+0200)
configuration ok
needs update: ....
----

Tras la validación, vamos a realizar la descarga de las listas. Para ello utilizaremos el comando `xlget_update`.

[source,console]
----
# xlget_update
INFO[0000] xlget (version: 341fe0e build: 2020-08-17T07:25:36+0200)
INFO[0000] getting 'blocklist.site-abuse'
INFO[0000] summary 'blocklist.site-abuse': updated=true ip4=0 ip6=0 domain=1220 md5=0 sha1=0 sha256=0
....
INFO[0081] xlget finished
----

En la salida pueden mostrarse algunos _warnings_ (que podremos ignorar si son de formato) y el número de elementos que se han extraído de cada una de las listas. Podemos ver que las listas se han descargado correctamente en el directorio `/var/lib/luids/xlist`.

Para despreocuparnos completamente de la actualización de las listas, inicializaremos el servicio `xlget` para que chequee automáticamente y actualice las listas si es necesario. Además lo habilitaremos para que se inicie con el sistema.

[source,bash]
----
sudo systemctl start luids-xlget
sudo systemctl enable luids-xlget
----

Podremos verificar que se inicia correctamente con el correspondiente `systemctl status luids-xlget`.

=== Configuración de xlistd

La configuración de `xlistd` se divide en dos partes:

* Definición del servicio.
* Parámetros de configuración del servidor.

La definición del servicio la realizaremos utilizando múltiples ficheros para que se entienda mejor. Deberemos crear los siguientes ficheros con su correspondiente contenido.

[source,bash]
----
cd /usr/local/share/xlist-database/database
sudo mkdir -p /etc/luids/xlist/services.d
sudo cp file/abuse-ch.json /etc/luids/xlist/services.d
sudo cp file/alienvault-com.json /etc/luids/xlist/services.d
sudo cp file/blocklist-site.json /etc/luids/xlist/services.d
sudo cp file/dshield-org.json /etc/luids/xlist/services.d
sudo cp file/emergingthreats-net.json /etc/luids/xlist/services.d
sudo cp file/interserver-net.json /etc/luids/xlist/services.d
sudo cp file/majestic-com.json /etc/luids/xlist/services.d
sudo cp file/myip-ms.json /etc/luids/xlist/services.d
sudo cp file/phishing-army.json /etc/luids/xlist/services.d
sudo cp file/spamhaus-org.json /etc/luids/xlist/services.d
sudo cp file/zerodot1-coinblockerlists.json /etc/luids/xlist/services.d
----

Editaremos los ficheros `json` recién copiados y sustituiremos `"disabled": true` por `false` en la definición de las listas enumeradas en el apartado <<design-sources>>.

Crearemos un fichero `custom-local.json` que contendrá la definición de nuestra listas negras locales.

.Contenido de `/etc/luids/xlist/services.d/custom-local.json`
[source,json]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/xlist/services.d/custom-local.json[]
----

Y crearemos nuestras listas locales.

[source,bash]
----
sudo touch /var/lib/luids/xlist/my-whitelist.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-malware.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-phising.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-reputation.xlist
sudo touch /var/lib/luids/xlist/my-blacklist-ads.xlist
----


Finalmente daremos forma a nuestro servicio de agregación.

.Contenido de `/etc/luids/xlist/service.json`
[source,json]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/xlist/service.json[]
----

Editaremos el fichero de configuración del servidor `xlistd` para que utilice nuestra nueva definición de servicio.

.Contenido de `/etc/luids/xlist/xlistd.toml`
[source,toml]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/xlist/xlistd.toml[]
----

Comprobaremos que la configuración es correcta, como se muestra a continuación.

[source,console]
----
# xlistd --config /etc/luids/xlist/xlistd.toml --dry-run
INFO[0000] xlistd (version: 341fe0e build: 2020-08-17T07:25:30+0200)
configuration seems ok
----

Inicializaremos y habilitaremos el servicio `xlistd`.

.Inicializa servicio `xlistd` y habilita al inicio
[source,bash]
----
sudo systemctl start luids-xlistd
sudo systemctl enable luids-xlistd
----

Podremos probar el correcto funcionamiento del servidor utilizando el comando `xlistc` para hacerle consultas.

[source,console]
----
$ xlistc
[ip4,domain] (2.666639ms)
$ xlistc www.google.com
domain,www.google.com: false,"",0 (603.587µs)
----

Con el servidor ya configurado, publicaremos el servicio en `apiservices.json` para que el resto de servicios lo puedan utilizar.

.Contenido temporal de `/etc/luids/apiservices.json`
[source,json]
----
[
    {
        "id": "xlist-sinkhole",
        "api": "luids.xlist.v1.Check",
        "endpoint": "tcp://127.0.0.1:5801"
    }
]
----

=== Configuración de luarchive

Definiremos los backends de archivado.

.Contenido de `/etc/luids/archive/backends.json`
[source,json]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/archive/backends.json[]
----

Definiremos los servicios a publicar por `luarchive`.

.Contenido de `/etc/luids/archive/services.json`
[source,json]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/archive/services.json[]
----

Configuraremos los parámetros del servidor.

.Contenido de `/etc/luids/archive/luarchive.toml`
[source,toml]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/archive/luarchive.toml[]
----

Probaremos la correcta configuración.

[source,console]
----
# luarchive --config /etc/luids/archive/luarchive.toml --dry-run
INFO[0000] luarchive (version: 874a460 build: 2020-09-03T17:43:38+0200)
configuration seems ok
----

Iniciaremos y habilitaremos el servicio.

[source,bash]
----
sudo systemctl start luids-luarchive
sudo systemctl enable luids-luarchive
----

Con el servidor ya configurado, publicaremos los servicios en `apiservices.json` para que el resto de servicios los puedan utilizar.

.Contenido temporal de `/etc/luids/apiservices.json`
[source,json]
----
[
    {
        "id": "xlist-sinkhole",
        "api": "luids.xlist.v1.Check",
        "endpoint": "tcp://127.0.0.1:5801"
    },
    {
        "id": "dnsutil-archive",
        "api": "luids.dnsutil.v1.Archive",
        "endpoint": "tcp://127.0.0.1:5821"
    },
    {
        "id": "event-archive",
        "api": "luids.event.v1.Archive",
        "endpoint": "tcp://127.0.0.1:5821"
    }
]
----

=== Descarga de base de datos de eventos

La manera más sencilla de obtener la base de datos es con un `git clone` o descargando la última release. Podremos dejar la base de datos

[source,bash]
----
git clone https://github.com/luids-io/event-database
sudo mv event-database /usr/local/share
----

=== Configuración de eventproc

En primer lugar copiaremos la definición de los tipos de eventos que vamos a procesar.

[source,bash]
----
sudo mkdir -p /etc/luids/event/events.d
cd /usr/local/share/event-database
sudo cp 00-test.json /etc/luids/event/events.d
sudo cp 02-dns.json /etc/luids/event/events.d
----

Definiremos la configuración de las stack de procesado.

.Contenido de `/etc/luids/event/stacks.json`
[source,json]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/event/stacks.json[]
----

Configuraremos los parámetros del servidor.

.Contenido de `/etc/luids/event/eventproc.toml`
[source,toml]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/event/eventproc.toml[]
----

Probaremos la configuración.

[source,console]
----
# eventproc --config /etc/luids/event/eventproc.toml --dry-run
INFO[0000] eventproc (version: a80418b build: 2020-09-03T17:43:31+0200)
INFO[0000] starting event processor (4 workers)
configuration seems ok
----

Iniciaremos y habilitaremos el servicio.

[source,bash]
----
sudo systemctl start luids-eventproc
sudo systemctl enable luids-eventproc
----

Podemos lanzar un evento de prueba utilizando la utilidad `eventnotify` como muestro a continuación y comprobar que se ha insertado el evento en la base de datos.

[source,bash]
----
$ echo '[ { "code": 10000, "data": { "test": "test message" } } ]' | eventnotify --stdin
3361ee82-0cd3-4644-a0c5-c8cff9880dc9
$ mongo
MongoDB shell version v3.6.8
connecting to: mongodb://127.0.0.1:27017
Implicit session: session { "id" : UUID("2445d5f5-d883-4d89-a39a-009e2834b07f") }
MongoDB server version: 3.6.8
> use luidsdb
switched to db luidsdb
> show collections
events
> db.getCollection("events").find()
{ "_id" : "3361ee82-0cd3-4644-a0c5-c8cff9880dc9", "code" : 10000, "level" : 0, "created" : ISODate("2020-09-03T17:26:13.170Z"), "source" : { "hostname" : "luids-router", "program" : "eventnotify", "instance" : "", "pid" : 2949 }, "data" : { "test" : "test message" }, "type" : 1, "codename" : "test.security", "description" : "Test event with data: test message", "processors" : [ { "received" : ISODate("2020-09-03T17:26:13.178Z"), "processor" : { "hostname" : "luids-router", "program" : "eventproc", "instance" : "", "pid" : 2928 } } ], "tags" : [ "test" ] }
> quit()
----

Con el servidor ya configurado y probado, publicaremos el servicio en `apiservices.json` para que el resto de servicios lo puedan utilizar.

.Contenido de `/etc/luids/apiservices.json`
[source,json]
----
include::{examplesdir}/advanced-dns-sinkhole/etc/luids/apiservices.json[]
----

=== Configuración de ludns

La configuración del servidor DNS la realizaremos en dos fases. En la primera fase lo pondremos a escuchar en el puerto no estándar `1053` para hacer pruebas y comprobar que funciona correctamente. En la segunda fase, que se verá en el apartado siguiente, haremos los pasos necesarios para ponerlo a escuchar en el puerto estándar.

Una vez hecho esto, la configuración del servicio `ludns` es muy sencilla, basta editar el fichero `/etc/luids/dns/Corefile`.

.Contenido temporal `/etc/luids/dns/Corefile`
[source]
----
.:1053 {
  idsapi
  idsevent
  resolvarchive {
     service dnsutil-archive
     server-ip 192.168.1.1
  }
  xlisthole {
     service xlist-sinkhole
     listed-domain merge log=true,dns=nxdomain
     unlisted-domain log=false,dns=checkip
     listed-ip merge log=true,dns=nxdomain,event=info
     #unlisted-ip log=false
     #on-error log=true,dns=return
  }
  forward . 8.8.8.8 8.8.4.4
}
----

Hay que iniciar el servidor.

[source,bash]
----
sudo systemctl start luids-ludns
----

Ahora vamos a llevar a cabo las pruebas del servicio utilizando para ello el comando `dig`.

[source,console]
----
# dig @localhost +short -p 1053 www.google.com //<1>
216.58.211.36
# head -1 /var/lib/luids/xlist/blocklist.site-malware.xlist //<2>
domain,100.1qingdao.com
# dig @8.8.4.4 +short 100.1qingdao.com //<3>
116.255.236.109
# dig @localhost +short -p 1053 100.1qingdao.com //<4>
----
<1> interrogamos al servidor local en puerto `1053` por el dominio
`www.google.com` y obtenemos respuesta.
<2> obtenemos el primer dominio listado en la lista de malware
<3> consultamos a un servidor DNS de google por la existencia del dominio y nos resonde
<4> consultamos a nuestro servidor local por el mismo dominio y no obtenemos
respuesta

Comprobamos en el log del servicio que se ha generado un nuevo evento de chequeo de lista y que lo ha encontrado en una de las listas, como se muestra a continuación.

[source,console]
----
# journalctl -u luids-ludns
...
sep 03 19:39:51 luids-router ludns[3726]: linux/amd64, go1.14.3,
sep 03 19:42:06 luids-router ludns[3726]: [INFO] plugin/xlisthole: [::1]:48554 check '100.1qingdao.com' response: true 'domain-malware'
----

También podemos comprobar la base de datos mongodb en la que veremos que tenemos la resolución realizada y el nuevo evento.

[source,bash]
----
$ mongo
> use luidsdb
switched to db luidsdb
> show collections
events
resolvs
> db.getCollection("resolvs").find()
{ "_id" : "ObjectIdHex(\"5f512a7899869d0978394282\")", "timestamp" : ISODate("2020-09-03T17:40:08.238Z"), "duration" : NumberLong(27), "serverip" : "192.168.1.1", "clientip" : "::1", "qid" : 32032, "name" : "www.google.com", "checkingdisabled" : false, "returncode" : 0, "authenticateddata" : false, "resolvedips" : [ "172.217.168.164" ] }
> db.getCollection("events").find()
...
{ "_id" : "22da0489-2e1e-43bf-89f7-750528a36baa", "code" : 10020, "level" : 2, "created" : ISODate("2020-09-03T17:42:06.325Z"), "source" : { "hostname" : "luids-router", "program" : "ludns", "instance" : "", "pid" : 3726 }, "data" : { "listed" : "100.1qingdao.com", "query" : "100.1qingdao.com", "reason" : "domain-malware: found in 'blocklist.site-malware'", "remote" : "::1" }, "type" : 1, "codename" : "dns.listed_domain", "description" : "Domain '100.1qingdao.com' listed has been resolved by ::1", "processors" : [ { "received" : ISODate("2020-09-03T17:42:06.327Z"), "processor" : { "hostname" : "luids-router", "program" : "eventproc", "instance" : "", "pid" : 2928 } } ], "tags" : [ "blacklist", "dns" ] }
> quit()
----


=== Consolidación servicio DNS

Ya tenemos un servidor DNS funcionando pero en un puerto no estándar, así que debemos cambiarlo al puerto que le corresponde. Sin embargo, aquí puede surgir un pequeño problema: puede existir un servidor DNS ya corriendo en dicho puerto.

Esto se debe a que muchas distribuciones optan por poner un pequeño servidor DNS funcionando por defecto para resolver las peticiones locales. Los más habituales son `systemd-resolved` y `dnsmasqd`.

Esta guía está realizada sobre un _Ubuntu 20.04_, por lo que desactivaremos `systemd-resolved` con los siguientes comandos.

[source,bash]
----
## deshabilito systemd-resolved
systemctl disable systemd-resolved.service
systemctl stop systemd-resolved.service

## borro symlink
rm -f /etc/resolv.conf

## creo nuevo resolv.conf que use el servidor dns local
cat >/etc/resolv.conf <<EOF
nameserver 127.0.0.1
options edns0
EOF
----

Ahora modificaremos la configuración de nuestro servidor DNS con la configuración definitiva.

.Contenido definitivo de `/etc/luids/dns/Corefile`
[source]
----
. {
   idsapi
   idsevent
   resolvarchive {
      service dnsutil-archive
      server-ip 192.168.1.1
   }
   xlisthole {
      service xlist-sinkhole
      listed-domain merge log=true,dns=nxdomain
      unlisted-domain log=false,dns=checkip
      listed-ip merge log=true,dns=nxdomain,event=info
      #unlisted-ip log=false
      #on-error log=true,dns=return
   }
   forward . 8.8.8.8 8.8.4.4
}
----

Reiniciaremos y habilitaremos el servicio al inicio.

[source,bash]
----
sudo systemctl restart luids-ludns
sudo systemctl enable luids-ludns
----

¡Ya tenemos configurado nuestro sumidero DNS!.

=== Configuración de los clientes

IMPORTANT: Los clientes se deberán configurar para que usen la _IP_ de nuestro
sumidero como *único servidor DNS*. De lo contrario algunas preguntas podrán
ser contestadas por otro servidor DNS que no haga el filtrado.

Una configuración adicional recomendada es permitir únicamente la salida de
tráfico DNS de nuestra red a nuestro servidor DNS. Esto no sólo evitará que
algunos usuarios puedan cambiarse la dirección del servidor DNS de forma manual
para evadir a nuestro sumidero, sino que también hará que posible malware use
servicios DNS públicos para evitar ser detectados.

//include::{partialsdir}/more.adoc[leveloffset=1]
