ifdef::env-site,env-github[= Guía: Sumidero DNS básico para bloquear publicidad, phising y malware]
include::{partialsdir}/attributes-es.adoc[]
ifdef::env-site,env-github[:toc:]

En la siguiente guía vamos a ver cómo configurar un *sumidero DNS*, también conocido como _DNS Sinkhole_ o _DNS Blackhole_, en nuestra red para así ocultar muchos de los molestos _banners_ publicitarios en todos nuestros dispositivos (ordenadores, smartphones, tablets, etc) o páginas conocidas de fraude y _phising_. Por si esto fuese poco, también detectaremos y bloquearemos algunas de las posibles conexiones de _malware_ que pudieran existir en nuestros dispositivos.

NOTE: Puedes realizar la configuración de esta guía *en menos de 5 minutos*
únicamente con la información de los apartados de <<installation>> y
<<configuration>>. Además tienes a tu disposición todos los ficheros de
configuración de esta guía
https://github.com/luids-io/docs/blob/master/es/modules/guides/examples/basic-sinkhole[aquí].

IMPORTANT: La configuración de esta guía también está disponible en `docker-compose` en el https://github.com/luids-io/deploy[repositorio de despliegues de luIDS]

[[introduction]]
== Introducción

=== Qué es un sumidero DNS o DNS Sinkhole

Un sumidero DNS es un servidor DNS que cumple el rol de _resolvedor_ en una red pero que, en lugar de devolver directamente a los clientes el resultado de una consulta DNS, comprobará si el nombre consultado se encuentra en una lista negra. Si se encontrase en la lista, entonces el sumidero no realizará la resolución y devolverá al cliente que el dominio no existe. Si el dominio no estuviese en la lista, el sumidero devolverá el resultado de la consulta al cliente.

Para entender mejor el funcionamiento, puede verse el siguiente diagrama de secuencia.

[[diagram-sinkhole-sequence]]
.Secuencia de un sumidero DNS con xlist
[plantuml, diagram-sinkhole-sequence, png, pdfwidth=70%]
----
actor dnsclient
participant "DNS Server\n(ludns)" as dnsserver
participant "XList Server\n(xlistd)" as xlist
participant "External\nDNS Server" as dnsext #99FF99

dnsclient -> dnsserver: query www.google.com
dnsserver -> xlist: Check(wwww.google.com)
xlist --> dnsserver: {result: false}
dnsserver -> dnsext: query www.google.com
dnsext --> dnsserver: 1.2.3.4
dnsserver --> dnsclient: 1.2.3.4

dnsclient -> dnsserver: query www.infected.com
dnsserver -> xlist: Check(wwww.infected.com)
xlist --> dnsserver:  {result: true, reason: "is malware"}
dnsserver --> dnsclient: nxdomain
----

=== ¿Qué tiene de especial nuestro sumidero?

Como probablemente conozca el lector, ya existe diverso software capaz de realizar esta labor, sin embargo la mayoría no es libre y el que es libre (como el popular BIND), usa un planteamiento distinto y, a nuestro juicio, menos versátil.

La particularidad de nuestro sumidero es que, como se vio en la figura <<diagram-sinkhole-sequence>>, involucra diferentes componentes: por un lado tenemos un servidor _DNS_ (basado en el popular _CoreDNS_) que realiza las tareas típicas de resolución y, por otro lado, tenemos un servidor _XList_ que se encarga de la tarea de comprobar la existencia en las listas. Esta separación de responsabilidades nos permitirá, además de una alta especialización de cada software en su correspondiente rol, implementar sistemas más robustos y escalables.

Esta guía se trata de una configuración básica así que no se verán todas las funcionalidades que ofrece nuestro sumidero. Sin embargo, conviene que el usuario las conozca por si se anima a continuar explorando más allá de esta guía. Algunas de las funcionalidades adicionales son:

* es capaz de comprobar también las IPs devueltas por los DNS,
* es posible definir puntuaciones y umbrales de respuesta,
* es posible diseñar un sistema de políticas que tenga en cuenta las distintas respuestas y puntuaciones,
* es capaz de enviar eventos a un sistema SIEM,
* provee de instrumentación para su integración en un sistema de monitorización _Prometheus_ y así tener información en "tiempo real",
* disponible en _Docker_ y con algunas características que lo hace ideal para su despliegue en entornos Cloud con herramientas como _Kubernetes_.

Así que una vez visto qué es un sumidero y qué ventajas aporta nuestro software sobre otros, pongámonos manos a la obra.

[[design]]
== Diseño del sistema

[[design-sources]]
=== Selección de los orígenes

En primer lugar vamos a seleccionar los orígenes que vamos a utilizar. Un buen sitio por donde empezar es https://github.com/luids-io/xlist-database[la base de datos XList].

Al tratarse de un sumidero DNS, vamos a querer una baja latencia en las consultas a las listas. Aquí tenemos dos opciones:

. Utilizar fuentes online de pago que nos garanticen calidad de servicio.
. Utilizar fuentes que puedan descargarse para su uso "offline".

Dado que el objetivo de esta guía es obtener un sumidero DNS para uso personal de forma gratuita, optaremos por la segunda opción. Además, debido a que queremos un sumidero que no chequee las IPs retornadas, únicamente utilizaremos listas con el recurso `domain`.

Para esta guía seleccionaremos las siguientes fuentes del magnífico proyecto https://blocklist.site y que ya se encuentran definidas en la base de datos.

* `blocklist.site-abuse`
* `blocklist.site-ads`
* `blocklist.site-crypto`
* `blocklist.site-fraud`
* `blocklist.site-malware`
* `blocklist.site-phishing`
* `blocklist.site-ransomware`
* `blocklist.site-scam`
* `blocklist.site-tracking`

Para minimizar los falsos positivos, utilizaremos también una lista blanca llamada `majestic.com-1000` que incluye los 1000 primeros sitios más visitados de https://majestic.com

Para mantener todas las listas que hemos seleccionado sincronizadas, lo que haremos será recurrir a la utilidad _xlget_. Para ello utilizaremos los https://github.com/luids-io/xlist-database/tree/master/database/feeds[feeds de la base de datos] correspondientes.

Además de estos orígenes externos, también daremos a nuestro sistema cierta flexibilidad, incorporando nuestras propias listas blancas y negras.

=== Diseño del servicio de listas

Nuestro servicio de listas será un servicio típico muy básico, que compruebe primero en listas blancas y después en listas negras. Como no vamos a utilizar puntuaciones y tampoco vamos a discriminar entre los distintos tipos de orígenes, queremos que nuestro sistema chequee y devuelva inmediatamente si encuentra un resultado positivo.

.Funcionamiento básico de nuestro sistema
[plantuml, flow-basic-sinkhole, png,pdfwidth=50%]
----
start
:read domain/
:check in whitelists|
if (check(domain)?) then (true)
	:result = false|
else (false)
	:check in blacklists|
	if (check(domain)?) then (true)
		:result = true|
	else (false)
		:result = false|
	endif
endif
stop
----

La definición gráfica del servicio mediante componentes de _xlistd_ sería la siguiente:

.Definición del servicio _xlistd_ para el sinkhole
image::design-basic-sinkhole.svg[design-sinkhole,width=85%,pdfwidth=100%]


=== Despliegue de los componentes

Como vamos a desplegar el software sobre un único sistema, el diagrama de despliegue quedará de la siguiente forma:

.*Diagrama de despliegue*
[plantuml, deployment-basic-sinkhole, png,pdfwidth=70%]
----
cloud "Blacklists" {
 [Web server] -down- HTTP
}

cloud "External Resolver" {
 [DNS Server] -down- ExtDNS
}

node "DNS Sinkhole" {
  database "Filesystem" {
    folder "/var/lib/luids/xlist" {
       [blacklist.xlist]
    }
  }
  [xlget] --> [blacklist.xlist]
  [blacklist.xlist] --> [xlistd]
  [xlget] --> HTTP
  [xlistd] - GRPC
  [ludns] --> GRPC
  [ludns] --> ExtDNS
  [ludns] - DNS
}

node "Client" {
  [DNS Resolver] --> DNS
}
----

NOTE: En esta guía únicamente desplegaremos los componentes `xlistd`, `xlget` y `ludns` vistos en el diagrama.

[[installation]]
== Instalación

WARNING: Este proceso está probado únicamente en un sistema _Ubuntu 20.04LTS_
server. Los binarios están compilados estáticamente y las rutas empleadas son
las de una distribución estándar, por lo que el instalador debería funcionar en
cualquier distribución. Si necesita más información o quiere instalarlo sobre
otras plataformas puede consultar los xref:manuals:index.adoc[manuales de las
herramientas].

IMPORTANT: Recuerde que si prefiere usar `docker` también puede desplegar el escenario de esta guía https://github.com/luis-io/deploy/basic-sinkhole[usando docker compose].

include::{partialsdir}/install-xlist.adoc[leveloffset=2]

include::{partialsdir}/install-dns.adoc[leveloffset=2]

TIP: Si está instalando en una Raspberry debe definir la arquitectura al lanzar el instalador con `sudo ARCH=arm64 ./installer.sh`

[[configuration]]
== Configuración

IMPORTANT: Puede descargar directamente los ficheros de configuración de esta guía https://github.com/luis-io/docs/blob/master/es/modules/guides/examples/basic-sinkhole[aquí].

=== Descarga de base de datos xlist

La manera más sencilla de obtener la base de datos es con un `git clone` o descargando la última release. Podremos dejar la base de datos

[source,bash]
----
git clone https://github.com/luids-io/xlist-database
sudo mv xlist-database /usr/local/share
----

=== Configuración de xlget

En primer lugar hay que configurar los orígenes de las listas negras definidas, para ello copiaremos de la base de datos xlist los ficheros de definición de `feeds` en `/etc/luids/xlist/sources.d`.

[source,bash]
----
cd /usr/local/share/xlist-database/database
sudo mkdir -p /etc/luids/xlist/sources.d
sudo cp feeds/blocklist-site.json /etc/luids/xlist/sources.d
sudo cp feeds/majestic-com.json /etc/luids/xlist/sources.d
----

Editaremos los ficheros `json` recién copiados y sustituiremos `"disabled": true` por `false` en la definición de las listas enumeradas en el apartado <<design-sources>>.

Editaremos el fichero de configuración de `xlget` para incluir el directorio como fuentes.

.Contenido de `/etc/luids/xlist/xlget.toml`
[source,toml]
----
include::{examplesdir}/basic-sinkhole/etc/luids/xlist/xlget.toml[]
----

Una vez creados dichos ficheros podemos chequear su correcta sintaxis mediante el comando `xlget_check`.

[source,console]
----
# xlget_check
INFO[0000] xlget (version: 341fe0e build: 2020-08-17T07:25:36+0200)
configuration ok
needs update: 'blocklist.site-abuse' 'blocklist.site-ads' 'blocklist.site-crypto' 'blocklist.site-fraud' 'blocklist.site-malware' 'blocklist.site-phishing' 'blocklist.site-ransomware' 'blocklist.site-scam' 'blocklist.site-tracking' 'majestic.com-1000'
----

Tras la validación, vamos a realizar la descarga de las listas. Para ello utilizaremos el comando `xlget_update`.

[source,console]
----
# xlget_update
INFO[0000] xlget (version: 341fe0e build: 2020-08-17T07:25:36+0200)
INFO[0000] getting 'blocklist.site-abuse'
INFO[0000] summary 'blocklist.site-abuse': updated=true ip4=0 ip6=0 domain=1220 md5=0 sha1=0 sha256=0
....
INFO[0081] xlget finished
----

En la salida pueden mostrarse algunos _warnings_ (que podremos ignorar si son de formato) y el número de elementos que se han extraído de cada una de las listas. Podemos ver que las listas se han descargado correctamente en el directorio `/var/lib/luids/xlist`.

Para despreocuparnos completamente de la actualización de las listas, inicializaremos el servicio `xlget` para que chequee automáticamente y actualice las listas si es necesario. Además lo habilitaremos para que se inicie con el sistema.

[source,bash]
----
sudo systemctl start luids-xlget
sudo systemctl enable luids-xlget
----

Podremos verificar que se inicia correctamente con el correspondiente `systemctl status luids-xlget`.

[source,console]
----
# systemctl status luids-xlget
● luids-xlget.service - xlget service
     Loaded: loaded (/etc/systemd/system/luids-xlget.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2020-08-17 08:04:25 CEST; 40s ago
   Main PID: 1714 (xlget)
      Tasks: 5 (limit: 1074)
     Memory: 1.9M
     CGroup: /system.slice/luids-xlget.service
             └─1714 /usr/local/bin/xlget --auto --config /etc/luids/xlist/xlget.toml

ago 17 08:04:25 luids-test systemd[1]: Started xlget service.
ago 17 08:04:25 luids-test xlget[1714]: time="2020-08-17T08:04:25+02:00" level=info msg="xlget (version: 341fe0e
----

=== Configuración de xlistd

La configuración de `xlistd` se divide en dos partes:

* Definición del servicio.
* Parámetros de configuración del servidor.

La definición del servicio la realizaremos utilizando múltiples ficheros para que se entienda mejor. Deberemos crear los siguientes ficheros con su correspondiente contenido.

[source,bash]
----
cd /usr/local/share/xlist-database/database
sudo mkdir -p /etc/luids/xlist/services.d
sudo cp file/blocklist-site.json /etc/luids/xlist/services.d
sudo cp file/majestic-com.json /etc/luids/xlist/services.d
----

Editaremos los ficheros `json` recién copiados y sustituiremos `"disabled": true` por `false` en la definición de las listas enumeradas en el apartado <<design-sources>>.

Crearemos un fichero `custom-local.json` que contendrá la definición de nuestra listas negras locales.

.Contenido de `/etc/luids/xlist/services.d/custom-local.json`
[source,json]
----
include::{examplesdir}/basic-sinkhole/etc/luids/xlist/services.d/custom-local.json[]
----

Y crearemos nuestras listas locales.

[source,bash]
----
sudo touch /var/lib/luis/xlist/my-blacklist.xlist
sudo touch /var/lib/luis/xlist/my-whitelist.xlist
----


Finalmente daremos forma a nuestro servicio de agregación.

.Contenido de `/etc/luids/xlist/service.json`
[source,json]
----
include::{examplesdir}/basic-sinkhole/etc/luids/xlist/service.json[]
----

Editaremos el fichero de configuración del servidor `xlistd` para que utilice nuestra nueva definición de servicio.

.Contenido de `/etc/luids/xlist/xlistd.toml`
[source,toml]
----
include::{examplesdir}/basic-sinkhole/etc/luids/xlist/xlistd.toml[]
----

Comprobaremos que la configuración es correcta, como se muestra a continuación.

[source,console]
----
# xlistd --config /etc/luids/xlist/xlistd.toml --dry-run
INFO[0000] xlistd (version: 341fe0e build: 2020-08-17T07:25:30+0200)
configuration seems ok
----

Inicializaremos y habilitaremos el servicio `xlistd`.

.Inicializa servicio `xlistd` y habilita al inicio
[source,bash]
----
sudo systemctl start luids-xlistd
sudo systemctl enable luids-xlistd
----

Podremos verificar que se inicia correctamente con el correspondiente `systemctl status luids-xlistd`.

[source,console]
----
# systemctl status luids-xlistd
● luids-xlistd.service - xlistd service
     Loaded: loaded (/etc/systemd/system/luids-xlistd.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2020-08-17 08:09:55 CEST; 1min 9s ago
   Main PID: 1780 (xlistd)
      Tasks: 6 (limit: 1074)
     Memory: 123.0M
     CGroup: /system.slice/luids-xlistd.service
             └─1780 /usr/local/bin/xlistd --config /etc/luids/xlist/xlistd.toml

ago 17 08:09:55 luids-test systemd[1]: Started xlistd service.
ago 17 08:09:55 luids-test xlistd[1780]: time="2020-08-17T08:09:55+02:00" level=info msg="xlistd (version: 341fe0>
ago 17 08:09:55 luids-test xlistd[1780]: time="2020-08-17T08:09:55+02:00" level=info msg="starting services"
ago 17 08:09:55 luids-test xlistd[1780]: time="2020-08-17T08:09:55+02:00" level=info msg="starting ids.api"
ago 17 08:09:55 luids-test xlistd[1780]: time="2020-08-17T08:09:55+02:00" level=info msg="starting xlist.service"
ago 17 08:09:55 luids-test xlistd[1780]: time="2020-08-17T08:09:55+02:00" level=info msg="starting xlist-builder >
ago 17 08:10:00 luids-test xlistd[1780]: time="2020-08-17T08:10:00+02:00" level=info msg="starting server.[tcp://>
ago 17 08:10:00 luids-test xlistd[1780]: time="2020-08-17T08:10:00+02:00" level=info msg="starting service.xlist.>
----

Podremos probar el correcto funcionamiento del servidor utilizando el comando `xlistc` para hacerle consultas.

[source,console]
----
$ xlistc
[domain] (2.666639ms)
$ xlistc www.google.com
domain,www.google.com: false,"",0 (603.587µs)
----

=== Configuración de ludns

La configuración del servidor DNS la realizaremos en dos fases. En la primera fase lo pondremos a escuchar en el puerto no estándar `1053` para hacer pruebas y comprobar que funciona correctamente. En la segunda fase, que se verá en el apartado siguiente, haremos los pasos necesarios para ponerlo a escuchar en el puerto estándar.

En primer lugar, debemos "publicar" (de forma local) el servicio de listas negras que hemos creado para que esté disponible para el servicio DNS. Esto lo haremos editando el fichero `etc/luids/apiservices.json`

.Contenido de `/etc/luids/apiservices.json`
[source,json]
----
include::{examplesdir}/basic-sinkhole/etc/luids/apiservices.json[]
----

Una vez hecho esto, la configuración del servicio `ludns`es muy sencilla, basta editar el fichero `/etc/luids/dns/Corefile`.

.Contenido temporal `/etc/luids/dns/Corefile`
[source]
----
.:1053 {
	idsapi
	xlisthole
	forward . 8.8.8.8 8.8.4.4
}
----

Hay que iniciar el servidor.

[source,bash]
----
systemctl start luids-ludns
----

Y puede comprobar que se ha iniciado correctamente como se ve en el ejemplo siguiente.

[source,console]
----
# systemctl status luids-ludns
● luids-ludns.service - ludns luIDS service
     Loaded: loaded (/etc/systemd/system/luids-ludns.service; disabled; vendor preset: enabled)
     Active: active (running) since Mon 2020-08-17 08:21:57 CEST; 32s ago
   Main PID: 1888 (ludns)
      Tasks: 6 (limit: 1074)
     Memory: 1.9M
     CGroup: /system.slice/luids-ludns.service
             └─1888 /usr/local/bin/ludns -conf /etc/luids/dns/Corefile

ago 17 08:21:57 luids-test systemd[1]: Started ludns luIDS service.
ago 17 08:21:57 luids-test ludns[1888]: .:1053
ago 17 08:21:57 luids-test ludns[1888]: CoreDNS-1.6.9
ago 17 08:21:57 luids-test ludns[1888]: linux/amd64, go1.14.3,
----

Ahora vamos a llevar a cabo las pruebas del servicio utilizando para ello el comando `dig`.

[source,console]
----
$ dig @localhost +short -p 1053 www.google.com //<1>
216.58.211.36
$ head -1 /var/lib/luids/xlist/blocklist.site-malware.xlist //<2>
domain,100.1qingdao.com
$ dig @8.8.4.4 +short 100.1qingdao.com //<3>
116.255.236.109
$ dig @localhost +short -p 1053 100.1qingdao.com //<4>
----
<1> interrogamos al servidor local en puerto `1053` por el dominio `www.google.com` y obtenemos respuesta.
<2> obtenemos el primer dominio listado en la lista de malware
<3> consultamos a un servidor DNS de google por la existencia del dominio y nos responde
<4> consultamos a nuestro servidor local por el mismo dominio y no obtenemos respuesta

Comprobamos en el log del servicio que se ha generado un nuevo evento de chequeo de lista y que lo ha encontrado en una de las listas, como se muestra a continuación.

[source,console]
----
# journalctl -u luids-ludns
....
ago 17 08:21:57 luids-test ludns[1888]: linux/amd64, go1.14.3,
ago 17 08:24:02 luids-test ludns[1888]: [INFO] plugin/xlisthole: [::1]:36056 check '100.1qingdao.com' response: true 'found in 'blocklist.site-malware''
----

=== Consolidación servicio DNS

Ya tenemos un servidor DNS funcionando pero en un puerto no estándar, así que debemos cambiarlo al puerto que le corresponde. Sin embargo, aquí puede surgir un pequeño problema: puede existir un servidor DNS ya corriendo en dicho puerto.

Esto se debe a que muchas distribuciones optan por poner un pequeño servidor DNS funcionando por defecto para resolver las peticiones locales. Los más habituales son `systemd-resolved` y `dnsmasqd`.

Esta guía está realizada sobre un _Ubuntu 20.04_, por lo que desactivaremos `systemd-resolved` con los siguientes comandos.

[source,bash]
----
## deshabilito systemd-resolved
sudo systemctl disable systemd-resolved.service
sudo systemctl stop systemd-resolved.service

## borro symlink
sudo rm -f /etc/resolv.conf

## creo nuevo resolv.conf que use el servidor dns local
sudo cat >/etc/resolv.conf <<EOF
nameserver 127.0.0.1
options edns0
EOF
----

Ahora modificaremos la configuración de nuestro servidor DNS con la configuración definitiva.

.Contenido definitivo de `/etc/luids/dns/Corefile`
[source]
----
. {
	idsapi
	xlisthole
	forward . 8.8.8.8 8.8.4.4
}
----

Reiniciaremos y habilitaremos el servicio al inicio.

[source,bash]
----
sudo systemctl restart luids-ludns
sudo systemctl enable luids-ludns
----

¡Ya tenemos configurado nuestro sumidero DNS!.

=== Configuración de los clientes

IMPORTANT: Los clientes se deberán configurar para que usen la _IP_ de nuestro sumidero como *único servidor DNS*. De lo contrario algunas preguntas podrán ser contestadas por otro servidor DNS que no haga el filtrado.

Una configuración adicional recomendada es permitir únicamente la salida de tráfico DNS de nuestra red a nuestro servidor DNS. Esto no sólo evitará que algunos usuarios puedan cambiarse la dirección del servidor DNS de forma manual para evadir a nuestro sumidero, sino que también hará que posible malware use servicios DNS públicos para evitar ser detectados.

//include::{partialsdir}/more.adoc[leveloffset=1]
