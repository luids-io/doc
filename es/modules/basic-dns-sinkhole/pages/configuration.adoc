= Configuración
include::{partialsdir}/attributes-es.adoc[]
:guidename: basic-dns-sinkhole

include::{partialsdir}/download-xlist-database.adoc[leveloffset=1]

== Configuración de xlget

Tras descargar la base de datos, es necesario en primer lugar configurar los orígenes de las listas que vamos a utilizar. para ello lo mejor es realizar enlaces simbólicos en `/etc/luids/xlist/sources.d`. De este modo, si un origen cambiase de url, formato, etc, nuestro sistema estará actualizado gracias a tener sincronizada la _base de datos xlist_.

[source,bash]
----
mkdir -p /etc/luids/xlist/sources.d
cd /etc/luids/xlist/sources.d
DBDIR=/usr/local/share/xlist-database
ln -s $DBDIR/sources/blocklist-site-abuse.json .
ln -s $DBDIR/sources/blocklist-site-ads.json .
ln -s $DBDIR/sources/blocklist-site-crypto.json .
ln -s $DBDIR/sources/blocklist-site-malware.json .
ln -s $DBDIR/sources/blocklist-site-phishing.json .
ln -s $DBDIR/sources/blocklist-site-ransomware.json .
ln -s $DBDIR/sources/blocklist-site-scam.json .
ln -s $DBDIR/sources/blocklist-site-tracking.json .
----

Editaremos el fichero de configuración de `xlget` para incluir el directorio como fuentes.

.Contenido de `/etc/luids/xlist/xlget.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/xlist/xlget.toml[]
----

Una vez creados dichos ficheros podemos chequear su correcta sintaxis mediante el comando `xlget_check` y posteriormente actualizar el contenido de las listas mediante el comando `xlget_update`.
----
# xlget_update
INFO[0000] xlget (version: 341fe0e build: 2020-08-17T07:25:36+0200)
INFO[0000] getting 'blocklist.site-abuse'
INFO[0000] summary 'blocklist.site-abuse': updated=true ip4=0 ip6=0 domain=1220 md5=0 sha1=0 sha256=0
....
INFO[0081] xlget finished
----

NOTE: En la salida pueden mostrarse algunos _warnings_ que podremos ignorar si son de formato.

Tras finalizar el proceso, podemos ver que las listas se han descargado correctamente en el directorio `/var/lib/luids/xlist` también podemos ver en el directorio `/var/lib/luids/xlist/status` información adicional sobre el estado de actualización del contenido de las listas.

Para despreocuparnos completamente de la actualización del contenido de las listas, inicializaremos el servicio `xlget` para que chequee automáticamente y actualice las listas si es necesario. Además lo habilitaremos para que se inicie con el sistema.

[source,bash]
----
sudo systemctl start luids-xlget
sudo systemctl enable luids-xlget
----

== Configuración de xlistd

La configuración de `xlistd` se divide en dos partes:

* Definición del servicio.
* Parámetros de configuración del servidor.

La definición del servicio la realizaremos utilizando múltiples ficheros para que se entienda mejor. Empezaremos por realizar enlaces simbólicos a las listas que vamos a utilizar.

[source,bash]
----
mkdir -p /etc/luids/xlist/services.d/files
cd /etc/luids/xlist/services.d/files
DBDIR=/usr/local/share/xlist-database
ln -s $DBDIR/services/files/blocklist-site-abuse.json .
ln -s $DBDIR/services/files/blocklist-site-ads.json .
ln -s $DBDIR/services/files/blocklist-site-crypto.json .
ln -s $DBDIR/services/files/blocklist-site-malware.json .
ln -s $DBDIR/services/files/blocklist-site-phishing.json .
ln -s $DBDIR/services/files/blocklist-site-ransomware.json .
ln -s $DBDIR/services/files/blocklist-site-scam.json .
ln -s $DBDIR/services/files/blocklist-site-tracking.json .
----

Crearemos un fichero `custom-local.json` que contendrá la definición de nuestra listas negras locales.

.Contenido de `/etc/luids/xlist/services.d/custom-local.json`
[source,json]
----
include::{examplesdir}/etc/luids/xlist/services.d/custom-local.json[]
----

Crearemos un fichero `blocklist-site.json` que incluirá una secuencia de las listas incluidas.

.Contenido de `/etc/luids/xlist/services.d/blocklist-site.json`
[source,json]
----
include::{examplesdir}/etc/luids/xlist/services.d/blocklist-site.json[]
----

Finalmente crearemos el componente raíz en el fichero `service.json` que dará forma a nuestro servicio de agregación.

.Contenido de `/etc/luids/xlist/service.json`
[source,json]
----
include::{examplesdir}/etc/luids/xlist/service.json[]
----

Editaremos el fichero de configuración del servidor `xlistd` para que utilice nuestra nueva definición de servicio.

.Contenido de `/etc/luids/xlist/xlistd.toml`
[source,toml]
----
include::{examplesdir}/etc/luids/xlist/xlistd.toml[]
----

Comprobaremos que la configuración es correcta con el siguiente comando.
[source,bash]
----
xlistd --config /etc/luids/xlist/xlistd.toml --dry-run
----

Inicializaremos y habilitaremos el servicio `xlistd`.
[source,bash]
----
sudo systemctl start luids-xlistd
sudo systemctl enable luids-xlistd
----

Podremos probar el correcto funcionamiento del servidor utilizando el comando `xlistc` para hacerle consultas.
----
$ xlistc
[domain] (2.666639ms)
$ xlistc www.google.com
domain,www.google.com: false,"",0 (603.587µs)
----

== Registro del servicio xlist

Para que el resto de componentes del ecosistema _^lu^IDS_ puedan utilizar nuestro servicio de listas, debemos "publicarlo" en el _registro de servicios de la API_. Esto lo haremos editando el fichero `/etc/luids/apiservices.json`

.Contenido de `/etc/luids/apiservices.json`
[source,json]
----
include::{examplesdir}/etc/luids/apiservices.json[]
----

== Configuración de ludns

La configuración del servidor DNS la realizaremos en dos fases. En la primera fase lo pondremos a escuchar en el puerto no estándar `1053` para hacer pruebas y comprobar que funciona correctamente. En la segunda fase, que se verá en el apartado siguiente, haremos los pasos necesarios para ponerlo a escuchar en el puerto estándar.

Una vez que el servicio `xlisthole` se encuentra disponible, la configuración del servicio `ludns` es muy sencilla, basta editar el fichero `/etc/luids/dns/Corefile`.

.Contenido temporal `/etc/luids/dns/Corefile`
[source]
----
.:1053 {
	idsapi
	xlisthole
	forward . 8.8.8.8 8.8.4.4
}
----

Iniciaremos el servidor con la nueva configuración.

[source,bash]
----
systemctl start luids-ludns
----

Y puede comprobar que se ha iniciado correctamente como se ve en el ejemplo siguiente.
----
# systemctl status luids-ludns
● luids-ludns.service - ludns luIDS service
     Loaded: loaded (/etc/systemd/system/luids-ludns.service; disabled; vendor preset: enabled)
     Active: active (running) since Mon 2020-08-17 08:21:57 CEST; 32s ago
   Main PID: 1888 (ludns)
      Tasks: 6 (limit: 1074)
     Memory: 1.9M
     CGroup: /system.slice/luids-ludns.service
             └─1888 /usr/local/bin/ludns -conf /etc/luids/dns/Corefile

ago 17 08:21:57 luids-test systemd[1]: Started ludns luIDS service.
ago 17 08:21:57 luids-test ludns[1888]: .:1053
ago 17 08:21:57 luids-test ludns[1888]: CoreDNS-1.6.9
ago 17 08:21:57 luids-test ludns[1888]: linux/amd64, go1.14.3,
----

Ahora llevaremos a cabo las pruebas del servicio utilizando para ello el comando `dig`.
----
$ dig @localhost +short -p 1053 www.google.com //<1>
216.58.211.36
$ head -1 /var/lib/luids/xlist/blocklist.site-malware.xlist //<2>
domain,100.1qingdao.com
$ dig @8.8.4.4 +short 100.1qingdao.com //<3>
116.255.236.109
$ dig @localhost +short -p 1053 100.1qingdao.com //<4>
----
<1> interrogamos al servidor local en puerto `1053` por el dominio `www.google.com` y obtenemos respuesta.
<2> obtenemos el primer dominio listado en la lista de malware
<3> consultamos a un servidor DNS de google por la existencia del dominio y nos responde
<4> consultamos a nuestro servidor local por el mismo dominio y no obtenemos respuesta

Comprobamos en el log del servicio que se ha generado un nuevo evento de chequeo de lista y que lo ha encontrado en una de las listas, como se muestra a continuación.

----
# journalctl -u luids-ludns
....
ago 17 08:21:57 luids-test ludns[1888]: linux/amd64, go1.14.3,
ago 17 08:24:02 luids-test ludns[1888]: [INFO] plugin/xlisthole: [::1]:36056 check '100.1qingdao.com' response: true 'found in 'blocklist.site-malware''
----

== Consolidación servicio DNS

Ya tenemos un servidor DNS funcionando pero en un puerto no estándar, así que debemos cambiarlo al puerto que le corresponde. Sin embargo, aquí puede surgir un pequeño problema: puede existir un servidor DNS ya corriendo en dicho puerto.

Esto se debe a que muchas distribuciones optan por poner un pequeño servidor DNS funcionando por defecto para resolver las peticiones locales. Los más habituales son `systemd-resolved` y `dnsmasqd`. En el caso de una distribución _Ubuntu server 20.04_, si comprobamos si hay algún proceso escuchando en el puerto `53`, obtenemos el siguiente resultado.
----
$ sudo ss -lunp | grep :53
UNCONN 0 0 127.0.0.53%lo:53 0.0.0.0:* users:(("systemd-resolve",pid=564,fd=12))
----

Podremos desactivar dicho servicio y definir que el resolver local utilice nuestro servicio DNS mediante los siguientes comandos.

[source,bash]
----
## deshabilito systemd-resolved
sudo systemctl disable systemd-resolved.service
sudo systemctl stop systemd-resolved.service

## borro symlink
sudo rm -f /etc/resolv.conf

## creo nuevo resolv.conf que use el servidor dns local
sudo cat >/etc/resolv.conf <<EOF
nameserver 127.0.0.1
options edns0
EOF
----

Modificaremos la configuración de nuestro servidor DNS con la configuración definitiva.

.Contenido de `/etc/luids/dns/Corefile`
[source]
----
. {
	idsapi
	xlisthole
	forward . 8.8.8.8 8.8.4.4
}
----

Reiniciaremos y habilitaremos el servicio al inicio.

[source,bash]
----
sudo systemctl restart luids-ludns
sudo systemctl enable luids-ludns
----

¡Enhorabuena! Ya puede presumir ante sus amigos y amigas de que ha configurado un sumidero DNS. Ahora sólo le queda (si no lo ha hecho ya) tener un hijo, escribir un libro y plantar un árbol ;).

== Configuración de los clientes

Ahora únicamente falta configurar los dispositivos de nuestra red para que usen como servidor DNS la dirección IP de nuestro servidor. Para ello algunos consejos:

* Deberemos configurar nuestro servidor como *único servidor DNS*, de lo contrario algunas preguntas podrán ser contestadas por otro servidor DNS que no haga el filtrado.
* Es recomendable hacer uso del protocolo DHCP para asignar la configuración DNS a los clientes.
* Es recomendable permitir únicamente la salida de tráfico DNS de nuestra red a nuestro sumidero DNS. Esto no sólo evitará que algunos usuarios puedan cambiarse la dirección del servidor DNS de forma manual para evadir a nuestro sumidero, sino que también hará que posible malware use servicios DNS públicos para evitar ser detectados.

ifdef::env-site,env-github[]
A continuación: xref:next-steps.adoc[Siguientes pasos]
endif::env-site,env-github[]

